# JavaFX-Inventory-Management-System
Inventory management system in Java.

This IMS application was completed as a final project for my Software I class (C482) at Western Governors University (WGU). The project was completed in Java, and I used NetBeans 12.3 as my IDE. JavaFX/FXML were used to build the GUI. For creating the scenes (screens) themselves, I used SceneBuilder. A GUI mockup for the scenes was provided as a guide, as well as UML class diagrams for the 5 classes used in this application. A Javadoc was also generated as required for the project.

Summary:
This simple inventory management system application is used to store Part and Product objects. Parts and Products each have their own TableView where they are displayed with some of their information. These objects are stored in static ObservableLists from the Inventory class. Parts and Products can be Added, Modified, or Deleted from the program. The Part.java class is abstract, and the file was provided by professors of the Software I class; as part of the project requirements, I was forbidden from making any changes to this class. Instead, we created two subclasses that inherit from the Part class: InHouseParts and OutsourcedParts. Product objects were not abstract, nor had any subclass, but contained an ObservableList<Part> of Part objects; just as a Product (such as a bike) is made up of many Parts (wheels, pedals, seat, frame), Part objects could be "associated" with a Product, and added to that Product's list of associated Parts.
  
With TableViews for Parts and Products populated with data, search TextFields on the main screen can be used to filter and search for Parts and/or Products by their uniquely generated ID or by their name. For either Parts or Products, when the Add button is pressed, users are brought to the Add Part/Product screens. Exception controls are used to prevent the user from saving the Part/Product with inappropriate data. If the TextFields on the Add Part/Product screens are valid, the data can be saved with the Save button. Back on the main screen, Parts/Products can be Modified, which will allow the user to select a Part/Product and modify it. Users are brought to the Modify Part/Product screen, which is identical to the Add Part/Product screen, but the TextFields are prepopulated with the selected object's information. Changes made here are then saved, retaining the selected object's uniquely generated ID.

Parts and Products can also be deleted from the main screen using their Delete buttons. While Parts can be deleted as-is, Products cannot be deleted if they contain Parts in their ObservableList of associated Parts. I.e: If a Product has Parts associated with it and the user attempts to delete that Product, the program will inform them that the selected Product cannot be deleted until Parts associated with it are removed or disassociated first. This can be done on the Modify Product screen. If a Product is modified to no longer contain associated Parts, then it may be deleted on the main screen. Even if a Part is associated with a Product, it can still be deleted from the Parts TableView on the main screen (e.g. like running out of wheel Parts for bike Products and deciding not to restock on wheels. The current bikes still have their wheels).
